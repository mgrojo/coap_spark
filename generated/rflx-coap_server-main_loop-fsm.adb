------------------------------------------------------------------------------
--                                                                          --
--               Generated by RecordFlux 0.25.0 on 2025-07-12               --
--                                                                          --
--                     Copyright (C) 2018-2025 AdaCore                      --
--                                                                          --
--         SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception          --
--                                                                          --
------------------------------------------------------------------------------

pragma Restrictions (No_Streams);
pragma Ada_2012;
pragma Style_Checks ("N3aAbCdefhiIklnOprStux");
pragma Warnings (Off, "redundant conversion");
with RFLX.CoAP_Server.Options_And_Payload_Data;
with RFLX.RFLX_Types.Operators;

package body RFLX.CoAP_Server.Main_Loop.FSM with
  SPARK_Mode
is

   use RFLX.RFLX_Types.Operators;

   use type RFLX.RFLX_Types.Bytes_Ptr;

   use type RFLX.RFLX_Types.Bit_Length;

   use type RFLX.CoAP.Length_16;

   use type RFLX.CoAP.Code_Class;

   pragma Warnings (Off, """*"" is already use-visible through previous use_type_clause");

   pragma Warnings (Off, "use clause for type ""*"" defined at * has no effect");

   use type RFLX.RFLX_Types.Base_Integer;

   pragma Warnings (On, "use clause for type ""*"" defined at * has no effect");

   pragma Warnings (On, """*"" is already use-visible through previous use_type_clause");

   procedure Receive_Request (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      function Receive_Request_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null
         and Ctx.P.Slots.Slot_Ptr_3 = null
         and Ctx.P.Slots.Slot_Ptr_4 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Receive_Request_Invariant);
      -- specs/coap_server.rflx:50:10
      CoAP.CoAP_Message.Verify_Message (Ctx.P.Request_Ctx);
      if CoAP.CoAP_Message.Well_Formed_Message (Ctx.P.Request_Ctx) then
         Ctx.P.Next_State := S_Treat_Request;
      else
         Ctx.P.Next_State := S_Failure;
      end if;
      pragma Assert (Receive_Request_Invariant);
   end Receive_Request;

   procedure Treat_Request (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      T_0 : RFLX.RFLX_Types.Base_Integer;
      T_1 : CoAP.Code_Class;
      T_2 : CoAP.Code_Class;
      T_3 : CoAP.Code_Class;
      function Treat_Request_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null
         and Ctx.P.Slots.Slot_Ptr_3 = null
         and Ctx.P.Slots.Slot_Ptr_4 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Treat_Request_Invariant);
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not (RFLX.RFLX_Types.Base_Integer (RFLX.RFLX_Types.Base_Integer'First) <= RFLX.RFLX_Types.Base_Integer (CoAP.CoAP_Message.Size (Ctx.P.Request_Ctx))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not (RFLX.RFLX_Types.Base_Integer (CoAP.CoAP_Message.Size (Ctx.P.Request_Ctx)) <= RFLX.RFLX_Types.Base_Integer (RFLX.RFLX_Types.Base_Integer'Last)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:60:37
      T_0 := RFLX.RFLX_Types.Base_Integer (CoAP.CoAP_Message.Size (Ctx.P.Request_Ctx));
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not (RFLX.RFLX_Types.Base_Integer (CoAP.Length_16'First) <= RFLX.RFLX_Types.Base_Integer (T_0)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not (RFLX.RFLX_Types.Base_Integer (T_0) <= RFLX.RFLX_Types.Base_Integer (CoAP.Length_16'Last)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:60:52
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not (8 /= 0) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Well_Formed_Message (Ctx.P.Request_Ctx) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:60:10
      if not CoAP_Server.Definite_Message.Valid_Next (Ctx.P.Definite_Request_Ctx, CoAP_Server.Definite_Message.F_Length) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      if not CoAP_Server.Definite_Message.Sufficient_Space (Ctx.P.Definite_Request_Ctx, CoAP_Server.Definite_Message.F_Length) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      if not RFLX.CoAP_Server.Definite_Message.Field_Condition (Ctx.P.Definite_Request_Ctx, RFLX.CoAP_Server.Definite_Message.F_Length) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      CoAP_Server.Definite_Message.Set_Length (Ctx.P.Definite_Request_Ctx, CoAP.Length_16'(CoAP.Length_16 (T_0) / 8));
      declare
         pragma Warnings (Off, "is not modified, could be declared constant");
         RFLX_Ctx_P_Request_Ctx_Tmp : CoAP.CoAP_Message.Context := Ctx.P.Request_Ctx;
         pragma Warnings (On, "is not modified, could be declared constant");
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP.CoAP_Message.Has_Buffer (RFLX_Ctx_P_Request_Ctx_Tmp)
            and then CoAP.CoAP_Message.Well_Formed_Message (RFLX_Ctx_P_Request_Ctx_Tmp)
            and then Length = CoAP.CoAP_Message.Byte_Size (RFLX_Ctx_P_Request_Ctx_Tmp));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            CoAP.CoAP_Message.Data (RFLX_Ctx_P_Request_Ctx_Tmp, Data);
         end RFLX_Process_Data;
         procedure RFLX_CoAP_Server_Definite_Message_Set_Message_Data is new CoAP_Server.Definite_Message.Generic_Set_Message_Data (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP_Server.Definite_Message.Valid_Next (Ctx.P.Definite_Request_Ctx, CoAP_Server.Definite_Message.F_Message_Data)
             and CoAP_Server.Definite_Message.Available_Space (Ctx.P.Definite_Request_Ctx, CoAP_Server.Definite_Message.F_Message_Data) >= RFLX_Types.To_Bit_Length (CoAP.CoAP_Message.Byte_Size (RFLX_Ctx_P_Request_Ctx_Tmp)))
         then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Treat_Request_Invariant);
            goto Finalize_Treat_Request;
         end if;
         if not CoAP_Server.Definite_Message.Valid_Length (Ctx.P.Definite_Request_Ctx, CoAP_Server.Definite_Message.F_Message_Data, CoAP.CoAP_Message.Byte_Size (RFLX_Ctx_P_Request_Ctx_Tmp)) then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Treat_Request_Invariant);
            goto Finalize_Treat_Request;
         end if;
         RFLX_CoAP_Server_Definite_Message_Set_Message_Data (Ctx.P.Definite_Request_Ctx, CoAP.CoAP_Message.Byte_Size (RFLX_Ctx_P_Request_Ctx_Tmp));
         Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
      end;
      -- specs/coap_server.rflx:63:10
      declare
         Definite_Response : CoAP_Server.Application_Response.Structure;
         Definite_Request : CoAP_Server.Definite_Message.Structure;
      begin
         CoAP_Server.Definite_Message.To_Structure (Ctx.P.Definite_Request_Ctx, Definite_Request);
         Get_Response (Ctx.E, Definite_Request, Definite_Response);
         if not CoAP_Server.Application_Response.Valid_Structure (Definite_Response) then
            Ctx.P.Next_State := S_Failure;
            pragma Assert (Treat_Request_Invariant);
            goto Finalize_Treat_Request;
         end if;
         if not CoAP_Server.Application_Response.Sufficient_Buffer_Length (Ctx.P.Definite_Response_Ctx, Definite_Response) then
            Ctx.P.Next_State := S_Failure;
            pragma Assert (Treat_Request_Invariant);
            goto Finalize_Treat_Request;
         end if;
         CoAP_Server.Application_Response.To_Context (Definite_Response, Ctx.P.Definite_Response_Ctx);
      end;
      -- specs/coap_server.rflx:66:35
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP_Server.Application_Response.Valid (Ctx.P.Definite_Response_Ctx, CoAP_Server.Application_Response.F_Message_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:66:35
      T_1 := CoAP_Server.Application_Response.Get_Message_Class (Ctx.P.Definite_Response_Ctx);
      -- specs/coap_server.rflx:67:40
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP_Server.Application_Response.Valid (Ctx.P.Definite_Response_Ctx, CoAP_Server.Application_Response.F_Message_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:67:40
      T_2 := CoAP_Server.Application_Response.Get_Message_Class (Ctx.P.Definite_Response_Ctx);
      -- specs/coap_server.rflx:68:40
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP_Server.Application_Response.Valid (Ctx.P.Definite_Response_Ctx, CoAP_Server.Application_Response.F_Message_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Request_Invariant);
         goto Finalize_Treat_Request;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:68:40
      T_3 := CoAP_Server.Application_Response.Get_Message_Class (Ctx.P.Definite_Response_Ctx);
      if T_1 = CoAP.Success then
         Ctx.P.Next_State := S_Success_Response;
      elsif T_2 = CoAP.Client_Error then
         Ctx.P.Next_State := S_Client_Error_Response;
      elsif T_3 = CoAP.Server_Error then
         Ctx.P.Next_State := S_Server_Error_Response;
      else
         Ctx.P.Next_State := S_Failure;
      end if;
      pragma Assert (Treat_Request_Invariant);
      <<Finalize_Treat_Request>>
   end Treat_Request;

   procedure Success_Response (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      function Success_Response_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null
         and Ctx.P.Slots.Slot_Ptr_3 = null
         and Ctx.P.Slots.Slot_Ptr_4 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Success_Response_Invariant);
      -- specs/coap_server.rflx:78:32
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_TKL) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:80:41
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP_Server.Application_Response.Valid (Ctx.P.Definite_Response_Ctx, CoAP_Server.Application_Response.F_Success_Code) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:81:39
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:82:34
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Well_Formed (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Token) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:84:28
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP_Server.Application_Response.Well_Formed (Ctx.P.Definite_Response_Ctx, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:76:13
      CoAP.CoAP_Message.Reset (Ctx.P.Response_Ctx);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Ver) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Ver, CoAP.To_Base_Integer (CoAP.First_Version)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      CoAP.CoAP_Message.Set_Ver (Ctx.P.Response_Ctx, CoAP.First_Version);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_T) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_T, CoAP.To_Base_Integer (CoAP.Non_Confirmable)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      CoAP.CoAP_Message.Set_T (Ctx.P.Response_Ctx, CoAP.Non_Confirmable);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_TKL) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_TKL, CoAP.To_Base_Integer (CoAP.Token_Length'(CoAP.CoAP_Message.Get_TKL (Ctx.P.Request_Ctx)))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      CoAP.CoAP_Message.Set_TKL (Ctx.P.Response_Ctx, CoAP.Token_Length'(CoAP.CoAP_Message.Get_TKL (Ctx.P.Request_Ctx)));
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Class, CoAP.To_Base_Integer (CoAP.Success)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      CoAP.CoAP_Message.Set_Class (Ctx.P.Response_Ctx, CoAP.Success);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Success_Code) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Success_Code, CoAP.To_Base_Integer (CoAP.Success_Response'(CoAP_Server.Application_Response.Get_Success_Code (Ctx.P.Definite_Response_Ctx)))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      CoAP.CoAP_Message.Set_Success_Code (Ctx.P.Response_Ctx, CoAP.Success_Response'(CoAP_Server.Application_Response.Get_Success_Code (Ctx.P.Definite_Response_Ctx)));
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Message_ID, CoAP.To_Base_Integer (CoAP.Message_ID_Type'(CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Request_Ctx)))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Response_Invariant);
         goto Finalize_Success_Response;
      end if;
      CoAP.CoAP_Message.Set_Message_ID (Ctx.P.Response_Ctx, CoAP.Message_ID_Type'(CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Request_Ctx)));
      declare
         pragma Warnings (Off, "is not modified, could be declared constant");
         RFLX_Ctx_P_Request_Ctx_Tmp : CoAP.CoAP_Message.Context := Ctx.P.Request_Ctx;
         pragma Warnings (On, "is not modified, could be declared constant");
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP.CoAP_Message.Has_Buffer (RFLX_Ctx_P_Request_Ctx_Tmp)
            and then CoAP.CoAP_Message.Well_Formed (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)
            and then Length = RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            CoAP.CoAP_Message.Get_Token (RFLX_Ctx_P_Request_Ctx_Tmp, Data);
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Token is new CoAP.CoAP_Message.Generic_Set_Token (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token))))
         then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Success_Response_Invariant);
            goto Finalize_Success_Response;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token, RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token))) then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Success_Response_Invariant);
            goto Finalize_Success_Response;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Token (Ctx.P.Response_Ctx, RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)));
         Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
      end;
      declare
         pragma Warnings (Off, "is not modified, could be declared constant");
         RFLX_Ctx_P_Definite_Response_Ctx_Tmp : CoAP_Server.Application_Response.Context := Ctx.P.Definite_Response_Ctx;
         pragma Warnings (On, "is not modified, could be declared constant");
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP_Server.Application_Response.Has_Buffer (RFLX_Ctx_P_Definite_Response_Ctx_Tmp)
            and then CoAP_Server.Application_Response.Well_Formed (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload)
            and then Length = RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            CoAP_Server.Application_Response.Get_Options_And_Payload_Options_And_Payload (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, Data);
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Options_And_Payload is new CoAP.CoAP_Message.Generic_Set_Options_And_Payload (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload))))
         then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Definite_Response_Ctx := RFLX_Ctx_P_Definite_Response_Ctx_Tmp;
            pragma Assert (Success_Response_Invariant);
            goto Finalize_Success_Response;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload, RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload))) then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Definite_Response_Ctx := RFLX_Ctx_P_Definite_Response_Ctx_Tmp;
            pragma Assert (Success_Response_Invariant);
            goto Finalize_Success_Response;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Options_And_Payload (Ctx.P.Response_Ctx, RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload)));
         Ctx.P.Definite_Response_Ctx := RFLX_Ctx_P_Definite_Response_Ctx_Tmp;
      end;
      if CoAP.CoAP_Message.Well_Formed_Message (Ctx.P.Response_Ctx) then
         Ctx.P.Next_State := S_Send_Response;
      else
         Ctx.P.Next_State := S_Failure;
      end if;
      pragma Assert (Success_Response_Invariant);
      <<Finalize_Success_Response>>
   end Success_Response;

   procedure Client_Error_Response (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      function Client_Error_Response_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null
         and Ctx.P.Slots.Slot_Ptr_3 = null
         and Ctx.P.Slots.Slot_Ptr_4 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Client_Error_Response_Invariant);
      -- specs/coap_server.rflx:98:32
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_TKL) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:100:46
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP_Server.Application_Response.Valid (Ctx.P.Definite_Response_Ctx, CoAP_Server.Application_Response.F_Client_Error_Code) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:101:39
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:102:34
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Well_Formed (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Token) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:104:28
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP_Server.Application_Response.Well_Formed (Ctx.P.Definite_Response_Ctx, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:96:10
      CoAP.CoAP_Message.Reset (Ctx.P.Response_Ctx);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Ver) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Ver, CoAP.To_Base_Integer (CoAP.First_Version)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_Ver (Ctx.P.Response_Ctx, CoAP.First_Version);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_T) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_T, CoAP.To_Base_Integer (CoAP.Non_Confirmable)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_T (Ctx.P.Response_Ctx, CoAP.Non_Confirmable);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_TKL) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_TKL, CoAP.To_Base_Integer (CoAP.Token_Length'(CoAP.CoAP_Message.Get_TKL (Ctx.P.Request_Ctx)))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_TKL (Ctx.P.Response_Ctx, CoAP.Token_Length'(CoAP.CoAP_Message.Get_TKL (Ctx.P.Request_Ctx)));
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Class, CoAP.To_Base_Integer (CoAP.Client_Error)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_Class (Ctx.P.Response_Ctx, CoAP.Client_Error);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Client_Error_Code) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Client_Error_Code, CoAP.To_Base_Integer (CoAP.Client_Error_Response'(CoAP_Server.Application_Response.Get_Client_Error_Code (Ctx.P.Definite_Response_Ctx)))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_Client_Error_Code (Ctx.P.Response_Ctx, CoAP.Client_Error_Response'(CoAP_Server.Application_Response.Get_Client_Error_Code (Ctx.P.Definite_Response_Ctx)));
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Message_ID, CoAP.To_Base_Integer (CoAP.Message_ID_Type'(CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Request_Ctx)))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Client_Error_Response_Invariant);
         goto Finalize_Client_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_Message_ID (Ctx.P.Response_Ctx, CoAP.Message_ID_Type'(CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Request_Ctx)));
      declare
         pragma Warnings (Off, "is not modified, could be declared constant");
         RFLX_Ctx_P_Request_Ctx_Tmp : CoAP.CoAP_Message.Context := Ctx.P.Request_Ctx;
         pragma Warnings (On, "is not modified, could be declared constant");
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP.CoAP_Message.Has_Buffer (RFLX_Ctx_P_Request_Ctx_Tmp)
            and then CoAP.CoAP_Message.Well_Formed (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)
            and then Length = RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            CoAP.CoAP_Message.Get_Token (RFLX_Ctx_P_Request_Ctx_Tmp, Data);
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Token is new CoAP.CoAP_Message.Generic_Set_Token (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token))))
         then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Client_Error_Response_Invariant);
            goto Finalize_Client_Error_Response;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token, RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token))) then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Client_Error_Response_Invariant);
            goto Finalize_Client_Error_Response;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Token (Ctx.P.Response_Ctx, RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)));
         Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
      end;
      declare
         pragma Warnings (Off, "is not modified, could be declared constant");
         RFLX_Ctx_P_Definite_Response_Ctx_Tmp : CoAP_Server.Application_Response.Context := Ctx.P.Definite_Response_Ctx;
         pragma Warnings (On, "is not modified, could be declared constant");
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP_Server.Application_Response.Has_Buffer (RFLX_Ctx_P_Definite_Response_Ctx_Tmp)
            and then CoAP_Server.Application_Response.Well_Formed (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload)
            and then Length = RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            CoAP_Server.Application_Response.Get_Options_And_Payload_Options_And_Payload (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, Data);
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Options_And_Payload is new CoAP.CoAP_Message.Generic_Set_Options_And_Payload (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload))))
         then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Definite_Response_Ctx := RFLX_Ctx_P_Definite_Response_Ctx_Tmp;
            pragma Assert (Client_Error_Response_Invariant);
            goto Finalize_Client_Error_Response;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload, RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload))) then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Definite_Response_Ctx := RFLX_Ctx_P_Definite_Response_Ctx_Tmp;
            pragma Assert (Client_Error_Response_Invariant);
            goto Finalize_Client_Error_Response;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Options_And_Payload (Ctx.P.Response_Ctx, RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload)));
         Ctx.P.Definite_Response_Ctx := RFLX_Ctx_P_Definite_Response_Ctx_Tmp;
      end;
      if CoAP.CoAP_Message.Well_Formed_Message (Ctx.P.Response_Ctx) then
         Ctx.P.Next_State := S_Send_Response;
      else
         Ctx.P.Next_State := S_Failure;
      end if;
      pragma Assert (Client_Error_Response_Invariant);
      <<Finalize_Client_Error_Response>>
   end Client_Error_Response;

   procedure Server_Error_Response (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      function Server_Error_Response_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null
         and Ctx.P.Slots.Slot_Ptr_3 = null
         and Ctx.P.Slots.Slot_Ptr_4 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Server_Error_Response_Invariant);
      -- specs/coap_server.rflx:118:32
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_TKL) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:120:46
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP_Server.Application_Response.Valid (Ctx.P.Definite_Response_Ctx, CoAP_Server.Application_Response.F_Server_Error_Code) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:121:39
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:122:34
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Well_Formed (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Token) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:124:28
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP_Server.Application_Response.Well_Formed (Ctx.P.Definite_Response_Ctx, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:116:10
      CoAP.CoAP_Message.Reset (Ctx.P.Response_Ctx);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Ver) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Ver, CoAP.To_Base_Integer (CoAP.First_Version)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_Ver (Ctx.P.Response_Ctx, CoAP.First_Version);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_T) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_T, CoAP.To_Base_Integer (CoAP.Non_Confirmable)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_T (Ctx.P.Response_Ctx, CoAP.Non_Confirmable);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_TKL) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_TKL, CoAP.To_Base_Integer (CoAP.Token_Length'(CoAP.CoAP_Message.Get_TKL (Ctx.P.Request_Ctx)))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_TKL (Ctx.P.Response_Ctx, CoAP.Token_Length'(CoAP.CoAP_Message.Get_TKL (Ctx.P.Request_Ctx)));
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Class, CoAP.To_Base_Integer (CoAP.Server_Error)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_Class (Ctx.P.Response_Ctx, CoAP.Server_Error);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Server_Error_Code) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Server_Error_Code, CoAP.To_Base_Integer (CoAP.Server_Error_Response'(CoAP_Server.Application_Response.Get_Server_Error_Code (Ctx.P.Definite_Response_Ctx)))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_Server_Error_Code (Ctx.P.Response_Ctx, CoAP.Server_Error_Response'(CoAP_Server.Application_Response.Get_Server_Error_Code (Ctx.P.Definite_Response_Ctx)));
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Message_ID, CoAP.To_Base_Integer (CoAP.Message_ID_Type'(CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Request_Ctx)))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Server_Error_Response_Invariant);
         goto Finalize_Server_Error_Response;
      end if;
      CoAP.CoAP_Message.Set_Message_ID (Ctx.P.Response_Ctx, CoAP.Message_ID_Type'(CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Request_Ctx)));
      declare
         pragma Warnings (Off, "is not modified, could be declared constant");
         RFLX_Ctx_P_Request_Ctx_Tmp : CoAP.CoAP_Message.Context := Ctx.P.Request_Ctx;
         pragma Warnings (On, "is not modified, could be declared constant");
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP.CoAP_Message.Has_Buffer (RFLX_Ctx_P_Request_Ctx_Tmp)
            and then CoAP.CoAP_Message.Well_Formed (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)
            and then Length = RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            CoAP.CoAP_Message.Get_Token (RFLX_Ctx_P_Request_Ctx_Tmp, Data);
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Token is new CoAP.CoAP_Message.Generic_Set_Token (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token))))
         then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Server_Error_Response_Invariant);
            goto Finalize_Server_Error_Response;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token, RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token))) then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Server_Error_Response_Invariant);
            goto Finalize_Server_Error_Response;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Token (Ctx.P.Response_Ctx, RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)));
         Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
      end;
      declare
         pragma Warnings (Off, "is not modified, could be declared constant");
         RFLX_Ctx_P_Definite_Response_Ctx_Tmp : CoAP_Server.Application_Response.Context := Ctx.P.Definite_Response_Ctx;
         pragma Warnings (On, "is not modified, could be declared constant");
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP_Server.Application_Response.Has_Buffer (RFLX_Ctx_P_Definite_Response_Ctx_Tmp)
            and then CoAP_Server.Application_Response.Well_Formed (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload)
            and then Length = RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            CoAP_Server.Application_Response.Get_Options_And_Payload_Options_And_Payload (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, Data);
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Options_And_Payload is new CoAP.CoAP_Message.Generic_Set_Options_And_Payload (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload))))
         then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Definite_Response_Ctx := RFLX_Ctx_P_Definite_Response_Ctx_Tmp;
            pragma Assert (Server_Error_Response_Invariant);
            goto Finalize_Server_Error_Response;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload, RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload))) then
            Ctx.P.Next_State := S_Failure;
            Ctx.P.Definite_Response_Ctx := RFLX_Ctx_P_Definite_Response_Ctx_Tmp;
            pragma Assert (Server_Error_Response_Invariant);
            goto Finalize_Server_Error_Response;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Options_And_Payload (Ctx.P.Response_Ctx, RFLX_Types.To_Length (CoAP_Server.Application_Response.Field_Size (RFLX_Ctx_P_Definite_Response_Ctx_Tmp, CoAP_Server.Application_Response.F_Options_And_Payload_Options_And_Payload)));
         Ctx.P.Definite_Response_Ctx := RFLX_Ctx_P_Definite_Response_Ctx_Tmp;
      end;
      if CoAP.CoAP_Message.Well_Formed_Message (Ctx.P.Response_Ctx) then
         Ctx.P.Next_State := S_Send_Response;
      else
         Ctx.P.Next_State := S_Failure;
      end if;
      pragma Assert (Server_Error_Response_Invariant);
      <<Finalize_Server_Error_Response>>
   end Server_Error_Response;

   procedure Send_Response (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      function Send_Response_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null
         and Ctx.P.Slots.Slot_Ptr_3 = null
         and Ctx.P.Slots.Slot_Ptr_4 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Send_Response_Invariant);
      -- specs/coap_server.rflx:136:10
      Ctx.P.Next_State := S_Receive_Request;
      pragma Assert (Send_Response_Invariant);
   end Send_Response;

   procedure Failure (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      Error_Data : CoAP_Server.Options_And_Payload_Data.Structure;
      function Failure_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null
         and Ctx.P.Slots.Slot_Ptr_3 = null
         and Ctx.P.Slots.Slot_Ptr_4 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Failure_Invariant);
      -- specs/coap_server.rflx:144:10
      Get_Error_Options_And_Payload (Ctx.E, Error_Data);
      if not CoAP_Server.Options_And_Payload_Data.Valid_Structure (Error_Data) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      -- specs/coap_server.rflx:148:29
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_TKL) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:151:36
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:152:31
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Well_Formed (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Token) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_server.rflx:146:10
      CoAP.CoAP_Message.Reset (Ctx.P.Response_Ctx);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Ver) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Ver, CoAP.To_Base_Integer (CoAP.First_Version)) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      CoAP.CoAP_Message.Set_Ver (Ctx.P.Response_Ctx, CoAP.First_Version);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_T) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_T, CoAP.To_Base_Integer (CoAP.Non_Confirmable)) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      CoAP.CoAP_Message.Set_T (Ctx.P.Response_Ctx, CoAP.Non_Confirmable);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_TKL) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_TKL, CoAP.To_Base_Integer (CoAP.Token_Length'(CoAP.CoAP_Message.Get_TKL (Ctx.P.Request_Ctx)))) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      CoAP.CoAP_Message.Set_TKL (Ctx.P.Response_Ctx, CoAP.Token_Length'(CoAP.CoAP_Message.Get_TKL (Ctx.P.Request_Ctx)));
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Class, CoAP.To_Base_Integer (CoAP.Server_Error)) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      CoAP.CoAP_Message.Set_Class (Ctx.P.Response_Ctx, CoAP.Server_Error);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Server_Error_Code) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Server_Error_Code, CoAP.To_Base_Integer (CoAP.Internal_Server_Error)) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      CoAP.CoAP_Message.Set_Server_Error_Code (Ctx.P.Response_Ctx, CoAP.Internal_Server_Error);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Response_Ctx, RFLX.CoAP.CoAP_Message.F_Message_ID, CoAP.To_Base_Integer (CoAP.Message_ID_Type'(CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Request_Ctx)))) then
         Ctx.P.Next_State := S_Receive_Request;
         pragma Assert (Failure_Invariant);
         goto Finalize_Failure;
      end if;
      CoAP.CoAP_Message.Set_Message_ID (Ctx.P.Response_Ctx, CoAP.Message_ID_Type'(CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Request_Ctx)));
      declare
         pragma Warnings (Off, "is not modified, could be declared constant");
         RFLX_Ctx_P_Request_Ctx_Tmp : CoAP.CoAP_Message.Context := Ctx.P.Request_Ctx;
         pragma Warnings (On, "is not modified, could be declared constant");
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP.CoAP_Message.Has_Buffer (RFLX_Ctx_P_Request_Ctx_Tmp)
            and then CoAP.CoAP_Message.Well_Formed (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)
            and then Length = RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            CoAP.CoAP_Message.Get_Token (RFLX_Ctx_P_Request_Ctx_Tmp, Data);
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Token is new CoAP.CoAP_Message.Generic_Set_Token (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token))))
         then
            Ctx.P.Next_State := S_Receive_Request;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Failure_Invariant);
            goto Finalize_Failure;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Token, RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token))) then
            Ctx.P.Next_State := S_Receive_Request;
            Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
            pragma Assert (Failure_Invariant);
            goto Finalize_Failure;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Token (Ctx.P.Response_Ctx, RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (RFLX_Ctx_P_Request_Ctx_Tmp, CoAP.CoAP_Message.F_Token)));
         Ctx.P.Request_Ctx := RFLX_Ctx_P_Request_Ctx_Tmp;
      end;
      declare
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP_Server.Options_And_Payload_Data.Valid_Structure (Error_Data)
            and then Length = RFLX_Types.To_Length (CoAP_Server.Options_And_Payload_Data.Field_Size_Options_And_Payload (Error_Data)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            if Data'Length > 0 then
               Data := Error_Data.Options_And_Payload (Error_Data.Options_And_Payload'First .. Error_Data.Options_And_Payload'First + RFLX_Types.Length'(Data'Length) - RFLX_Types.Length'(1));
            else
               Data := (others => 0);
            end if;
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Options_And_Payload is new CoAP.CoAP_Message.Generic_Set_Options_And_Payload (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP_Server.Options_And_Payload_Data.Field_Size_Options_And_Payload (Error_Data))))
         then
            Ctx.P.Next_State := S_Receive_Request;
            pragma Assert (Failure_Invariant);
            goto Finalize_Failure;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload, RFLX_Types.To_Length (CoAP_Server.Options_And_Payload_Data.Field_Size_Options_And_Payload (Error_Data))) then
            Ctx.P.Next_State := S_Receive_Request;
            pragma Assert (Failure_Invariant);
            goto Finalize_Failure;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Options_And_Payload (Ctx.P.Response_Ctx, RFLX_Types.To_Length (CoAP_Server.Options_And_Payload_Data.Field_Size_Options_And_Payload (Error_Data)));
      end;
      Ctx.P.Next_State := S_Send_Response;
      pragma Assert (Failure_Invariant);
      <<Finalize_Failure>>
   end Failure;

   procedure Initialize (Ctx : in out Context) is
      Request_Buffer : RFLX_Types.Bytes_Ptr;
      Response_Buffer : RFLX_Types.Bytes_Ptr;
      Definite_Request_Buffer : RFLX_Types.Bytes_Ptr;
      Definite_Response_Buffer : RFLX_Types.Bytes_Ptr;
   begin
      CoAP_Server.Main_Loop.FSM_Allocator.Initialize (Ctx.P.Slots, Ctx.P.Memory);
      Request_Buffer := Ctx.P.Slots.Slot_Ptr_1;
      pragma Warnings (Off, "unused assignment");
      Ctx.P.Slots.Slot_Ptr_1 := null;
      pragma Warnings (On, "unused assignment");
      CoAP.CoAP_Message.Initialize (Ctx.P.Request_Ctx, Request_Buffer);
      Response_Buffer := Ctx.P.Slots.Slot_Ptr_2;
      pragma Warnings (Off, "unused assignment");
      Ctx.P.Slots.Slot_Ptr_2 := null;
      pragma Warnings (On, "unused assignment");
      CoAP.CoAP_Message.Initialize (Ctx.P.Response_Ctx, Response_Buffer);
      Definite_Request_Buffer := Ctx.P.Slots.Slot_Ptr_3;
      pragma Warnings (Off, "unused assignment");
      Ctx.P.Slots.Slot_Ptr_3 := null;
      pragma Warnings (On, "unused assignment");
      CoAP_Server.Definite_Message.Initialize (Ctx.P.Definite_Request_Ctx, Definite_Request_Buffer);
      Definite_Response_Buffer := Ctx.P.Slots.Slot_Ptr_4;
      pragma Warnings (Off, "unused assignment");
      Ctx.P.Slots.Slot_Ptr_4 := null;
      pragma Warnings (On, "unused assignment");
      CoAP_Server.Application_Response.Initialize (Ctx.P.Definite_Response_Ctx, Definite_Response_Buffer);
      Ctx.P.Next_State := S_Receive_Request;
   end Initialize;

   procedure Finalize (Ctx : in out Context) is
      Request_Buffer : RFLX_Types.Bytes_Ptr;
      Response_Buffer : RFLX_Types.Bytes_Ptr;
      Definite_Request_Buffer : RFLX_Types.Bytes_Ptr;
      Definite_Response_Buffer : RFLX_Types.Bytes_Ptr;
   begin
      pragma Warnings (Off, """Ctx.P.Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      CoAP.CoAP_Message.Take_Buffer (Ctx.P.Request_Ctx, Request_Buffer);
      pragma Warnings (On, """Ctx.P.Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      pragma Assert (Ctx.P.Slots.Slot_Ptr_1 = null);
      pragma Assert (Request_Buffer /= null);
      Ctx.P.Slots.Slot_Ptr_1 := Request_Buffer;
      pragma Assert (Ctx.P.Slots.Slot_Ptr_1 /= null);
      pragma Warnings (Off, """Ctx.P.Response_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      CoAP.CoAP_Message.Take_Buffer (Ctx.P.Response_Ctx, Response_Buffer);
      pragma Warnings (On, """Ctx.P.Response_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      pragma Assert (Ctx.P.Slots.Slot_Ptr_2 = null);
      pragma Assert (Response_Buffer /= null);
      Ctx.P.Slots.Slot_Ptr_2 := Response_Buffer;
      pragma Assert (Ctx.P.Slots.Slot_Ptr_2 /= null);
      pragma Warnings (Off, """Ctx.P.Definite_Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      CoAP_Server.Definite_Message.Take_Buffer (Ctx.P.Definite_Request_Ctx, Definite_Request_Buffer);
      pragma Warnings (On, """Ctx.P.Definite_Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      pragma Assert (Ctx.P.Slots.Slot_Ptr_3 = null);
      pragma Assert (Definite_Request_Buffer /= null);
      Ctx.P.Slots.Slot_Ptr_3 := Definite_Request_Buffer;
      pragma Assert (Ctx.P.Slots.Slot_Ptr_3 /= null);
      pragma Warnings (Off, """Ctx.P.Definite_Response_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      CoAP_Server.Application_Response.Take_Buffer (Ctx.P.Definite_Response_Ctx, Definite_Response_Buffer);
      pragma Warnings (On, """Ctx.P.Definite_Response_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      pragma Assert (Ctx.P.Slots.Slot_Ptr_4 = null);
      pragma Assert (Definite_Response_Buffer /= null);
      Ctx.P.Slots.Slot_Ptr_4 := Definite_Response_Buffer;
      pragma Assert (Ctx.P.Slots.Slot_Ptr_4 /= null);
      CoAP_Server.Main_Loop.FSM_Allocator.Finalize (Ctx.P.Slots);
      Ctx.P.Next_State := S_Final;
   end Finalize;

   procedure Reset_Messages_Before_Write (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
   begin
      case Ctx.P.Next_State is
         when S_Receive_Request =>
            CoAP.CoAP_Message.Reset (Ctx.P.Request_Ctx, Ctx.P.Request_Ctx.First, Ctx.P.Request_Ctx.First - 1);
         when S_Treat_Request | S_Success_Response | S_Client_Error_Response | S_Server_Error_Response | S_Send_Response | S_Failure | S_Final =>
            null;
      end case;
   end Reset_Messages_Before_Write;

   procedure Tick (Ctx : in out Context) is
   begin
      case Ctx.P.Next_State is
         when S_Receive_Request =>
            Receive_Request (Ctx);
         when S_Treat_Request =>
            Treat_Request (Ctx);
         when S_Success_Response =>
            Success_Response (Ctx);
         when S_Client_Error_Response =>
            Client_Error_Response (Ctx);
         when S_Server_Error_Response =>
            Server_Error_Response (Ctx);
         when S_Send_Response =>
            Send_Response (Ctx);
         when S_Failure =>
            Failure (Ctx);
         when S_Final =>
            null;
      end case;
      Reset_Messages_Before_Write (Ctx);
   end Tick;

   function In_IO_State (Ctx : Context) return Boolean is
     (Ctx.P.Next_State in S_Receive_Request | S_Send_Response);

   procedure Run (Ctx : in out Context) is
   begin
      Tick (Ctx);
      while
         Active (Ctx)
         and not In_IO_State (Ctx)
      loop
         pragma Loop_Invariant (Initialized (Ctx));
         Tick (Ctx);
      end loop;
   end Run;

   procedure Read (Ctx : Context; Chan : Channel; Buffer : out RFLX_Types.Bytes; Offset : RFLX_Types.Length := 0) is
      function Read_Pre (Message_Buffer : RFLX_Types.Bytes) return Boolean is
        (Buffer'Length > 0
         and then Offset < Message_Buffer'Length);
      procedure Read (Message_Buffer : RFLX_Types.Bytes) with
        Pre =>
          Read_Pre (Message_Buffer)
      is
         Length : constant RFLX_Types.Length := RFLX_Types.Length'Min (Buffer'Length, Message_Buffer'Length - Offset);
         Buffer_Last : constant RFLX_Types.Index := Buffer'First + (Length - RFLX_Types.Length'(1));
      begin
         Buffer (Buffer'First .. RFLX_Types.Index (Buffer_Last)) := Message_Buffer (RFLX_Types.Index (RFLX_Types.Length (Message_Buffer'First) + Offset) .. Message_Buffer'First + Offset + (Length - RFLX_Types.Length'(1)));
      end Read;
      procedure CoAP_CoAP_Message_Read is new CoAP.CoAP_Message.Generic_Read (Read, Read_Pre);
   begin
      Buffer := (others => 0);
      case Chan is
         when C_Transport =>
            case Ctx.P.Next_State is
               when S_Send_Response =>
                  CoAP_CoAP_Message_Read (Ctx.P.Response_Ctx);
               when others =>
                  pragma Warnings (Off, "unreachable code");
                  null;
                  pragma Warnings (On, "unreachable code");
            end case;
      end case;
   end Read;

   procedure Write (Ctx : in out Context; Chan : Channel; Buffer : RFLX_Types.Bytes; Offset : RFLX_Types.Length := 0) is
      Write_Buffer_Length : constant RFLX_Types.Length := Write_Buffer_Size (Ctx, Chan);
      function Write_Pre (Context_Buffer_Length : RFLX_Types.Length; Offset : RFLX_Types.Length) return Boolean is
        (Buffer'Length > 0
         and then Context_Buffer_Length = Write_Buffer_Length
         and then Offset <= RFLX_Types.Length'Last - Buffer'Length
         and then Buffer'Length + Offset <= Write_Buffer_Length);
      procedure Write (Message_Buffer : out RFLX_Types.Bytes; Length : out RFLX_Types.Length; Context_Buffer_Length : RFLX_Types.Length; Offset : RFLX_Types.Length) with
        Pre =>
          Write_Pre (Context_Buffer_Length, Offset)
          and then Offset <= RFLX_Types.Length'Last - Message_Buffer'Length
          and then Message_Buffer'Length + Offset = Write_Buffer_Length,
        Post =>
          Length <= Message_Buffer'Length
      is
      begin
         Length := Buffer'Length;
         Message_Buffer := (others => 0);
         Message_Buffer (Message_Buffer'First .. RFLX_Types.Index (RFLX_Types.Length (Message_Buffer'First) - 1 + Length)) := Buffer;
      end Write;
      procedure CoAP_CoAP_Message_Write is new CoAP.CoAP_Message.Generic_Write (Write, Write_Pre);
   begin
      case Chan is
         when C_Transport =>
            case Ctx.P.Next_State is
               when S_Receive_Request =>
                  CoAP_CoAP_Message_Write (Ctx.P.Request_Ctx, Offset);
               when others =>
                  pragma Warnings (Off, "unreachable code");
                  null;
                  pragma Warnings (On, "unreachable code");
            end case;
      end case;
   end Write;

end RFLX.CoAP_Server.Main_Loop.FSM;
