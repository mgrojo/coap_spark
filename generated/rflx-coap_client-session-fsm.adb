------------------------------------------------------------------------------
--                                                                          --
--               Generated by RecordFlux 0.25.0 on 2025-02-23               --
--                                                                          --
--                     Copyright (C) 2018-2025 AdaCore                      --
--                                                                          --
--         SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception          --
--                                                                          --
------------------------------------------------------------------------------

pragma Restrictions (No_Streams);
pragma Ada_2012;
pragma Style_Checks ("N3aAbCdefhiIklnOprStux");
pragma Warnings (Off, "redundant conversion");
with RFLX.CoAP_Client.Token_Data;
with RFLX.CoAP_Client.Options_And_Payload_Data;
with RFLX.RFLX_Types.Operators;

package body RFLX.CoAP_Client.Session.FSM with
  SPARK_Mode
is

   use RFLX.RFLX_Types.Operators;

   use type RFLX.RFLX_Types.Bytes_Ptr;

   use type RFLX.RFLX_Types.Bit_Length;

   use type RFLX.CoAP.Code_Class;

   pragma Warnings (Off, """*"" is already use-visible through previous use_type_clause");

   pragma Warnings (Off, "use clause for type ""*"" defined at * has no effect");

   use type RFLX.RFLX_Types.Base_Integer;

   pragma Warnings (On, "use clause for type ""*"" defined at * has no effect");

   pragma Warnings (On, """*"" is already use-visible through previous use_type_clause");

   procedure Create_Request (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      Method : CoAP.Method_Code;
      Random_Token : CoAP_Client.Token_Data.Structure;
      Options_And_Payload : CoAP_Client.Options_And_Payload_Data.Structure;
      function Create_Request_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Create_Request_Invariant);
      -- specs/coap_client.rflx:42:10
      Get_New_Message_ID (Ctx.E, Ctx.P.Messsage_ID);
      -- specs/coap_client.rflx:43:10
      Get_Method (Ctx.E, Method);
      -- specs/coap_client.rflx:44:10
      Get_Random_Token (Ctx.E, Random_Token);
      if not CoAP_Client.Token_Data.Valid_Structure (Random_Token) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      -- specs/coap_client.rflx:45:10
      Get_Options_And_Payload (Ctx.E, Options_And_Payload);
      if not CoAP_Client.Options_And_Payload_Data.Valid_Structure (Options_And_Payload) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      -- specs/coap_client.rflx:47:10
      CoAP.CoAP_Message.Reset (Ctx.P.Request_Ctx);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Ver) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Request_Ctx, RFLX.CoAP.CoAP_Message.F_Ver, CoAP.To_Base_Integer (CoAP.First_Version)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      CoAP.CoAP_Message.Set_Ver (Ctx.P.Request_Ctx, CoAP.First_Version);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_T) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Request_Ctx, RFLX.CoAP.CoAP_Message.F_T, CoAP.To_Base_Integer (CoAP.Confirmable)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      CoAP.CoAP_Message.Set_T (Ctx.P.Request_Ctx, CoAP.Confirmable);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_TKL) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Request_Ctx, RFLX.CoAP.CoAP_Message.F_TKL, CoAP.To_Base_Integer (CoAP.Token_Length'(Random_Token.Length))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      CoAP.CoAP_Message.Set_TKL (Ctx.P.Request_Ctx, CoAP.Token_Length'(Random_Token.Length));
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Request_Ctx, RFLX.CoAP.CoAP_Message.F_Class, CoAP.To_Base_Integer (CoAP.Request)) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      CoAP.CoAP_Message.Set_Class (Ctx.P.Request_Ctx, CoAP.Request);
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Method) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Request_Ctx, RFLX.CoAP.CoAP_Message.F_Method, CoAP.To_Base_Integer (CoAP.Method_Code'(Method))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      CoAP.CoAP_Message.Set_Method (Ctx.P.Request_Ctx, CoAP.Method_Code'(Method));
      if not CoAP.CoAP_Message.Sufficient_Space (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      if not RFLX.CoAP.CoAP_Message.Field_Condition (Ctx.P.Request_Ctx, RFLX.CoAP.CoAP_Message.F_Message_ID, CoAP.To_Base_Integer (CoAP.Message_ID_Type'(Ctx.P.Messsage_ID))) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Create_Request_Invariant);
         goto Finalize_Create_Request;
      end if;
      CoAP.CoAP_Message.Set_Message_ID (Ctx.P.Request_Ctx, CoAP.Message_ID_Type'(Ctx.P.Messsage_ID));
      declare
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP_Client.Token_Data.Valid_Structure (Random_Token)
            and then Length = RFLX_Types.To_Length (CoAP_Client.Token_Data.Field_Size_Token (Random_Token)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            if Data'Length > 0 then
               Data := Random_Token.Token (Random_Token.Token'First .. Random_Token.Token'First + RFLX_Types.Length'(Data'Length) - RFLX_Types.Length'(1));
            else
               Data := (others => 0);
            end if;
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Token is new CoAP.CoAP_Message.Generic_Set_Token (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Token)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Token) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP_Client.Token_Data.Field_Size_Token (Random_Token))))
         then
            Ctx.P.Next_State := S_Failure;
            pragma Assert (Create_Request_Invariant);
            goto Finalize_Create_Request;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Token, RFLX_Types.To_Length (CoAP_Client.Token_Data.Field_Size_Token (Random_Token))) then
            Ctx.P.Next_State := S_Failure;
            pragma Assert (Create_Request_Invariant);
            goto Finalize_Create_Request;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Token (Ctx.P.Request_Ctx, RFLX_Types.To_Length (CoAP_Client.Token_Data.Field_Size_Token (Random_Token)));
      end;
      declare
         function RFLX_Process_Data_Pre (Length : RFLX_Types.Length) return Boolean is
           (CoAP_Client.Options_And_Payload_Data.Valid_Structure (Options_And_Payload)
            and then Length = RFLX_Types.To_Length (CoAP_Client.Options_And_Payload_Data.Field_Size_Options_And_Payload (Options_And_Payload)));
         procedure RFLX_Process_Data (Data : out RFLX_Types.Bytes) with
           Pre =>
             RFLX_Process_Data_Pre (Data'Length)
         is
         begin
            if Data'Length > 0 then
               Data := Options_And_Payload.Options_And_Payload (Options_And_Payload.Options_And_Payload'First .. Options_And_Payload.Options_And_Payload'First + RFLX_Types.Length'(Data'Length) - RFLX_Types.Length'(1));
            else
               Data := (others => 0);
            end if;
         end RFLX_Process_Data;
         procedure RFLX_CoAP_CoAP_Message_Set_Options_And_Payload is new CoAP.CoAP_Message.Generic_Set_Options_And_Payload (RFLX_Process_Data, RFLX_Process_Data_Pre);
      begin
         if
            not (CoAP.CoAP_Message.Valid_Next (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Options_And_Payload)
             and CoAP.CoAP_Message.Available_Space (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Options_And_Payload) >= RFLX_Types.To_Bit_Length (RFLX_Types.To_Length (CoAP_Client.Options_And_Payload_Data.Field_Size_Options_And_Payload (Options_And_Payload))))
         then
            Ctx.P.Next_State := S_Failure;
            pragma Assert (Create_Request_Invariant);
            goto Finalize_Create_Request;
         end if;
         if not CoAP.CoAP_Message.Valid_Length (Ctx.P.Request_Ctx, CoAP.CoAP_Message.F_Options_And_Payload, RFLX_Types.To_Length (CoAP_Client.Options_And_Payload_Data.Field_Size_Options_And_Payload (Options_And_Payload))) then
            Ctx.P.Next_State := S_Failure;
            pragma Assert (Create_Request_Invariant);
            goto Finalize_Create_Request;
         end if;
         RFLX_CoAP_CoAP_Message_Set_Options_And_Payload (Ctx.P.Request_Ctx, RFLX_Types.To_Length (CoAP_Client.Options_And_Payload_Data.Field_Size_Options_And_Payload (Options_And_Payload)));
      end;
      Ctx.P.Next_State := S_Send_Request;
      pragma Assert (Create_Request_Invariant);
      <<Finalize_Create_Request>>
   end Create_Request;

   procedure Send_Request (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      function Send_Request_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Send_Request_Invariant);
      -- specs/coap_client.rflx:64:10
      Ctx.P.Next_State := S_Receive_Response;
      pragma Assert (Send_Request_Invariant);
   end Send_Request;

   procedure Receive_Response (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      T_0 : Boolean;
      T_1 : CoAP.Message_ID_Type;
      T_2 : Boolean;
      T_3 : Boolean;
      T_4 : CoAP.Code_Class;
      T_5 : Boolean;
      T_6 : Boolean;
      T_7 : CoAP.Message_ID_Type;
      T_8 : Boolean;
      T_9 : Boolean;
      T_10 : CoAP.Code_Class;
      T_11 : Boolean;
      T_12 : CoAP.Code_Class;
      T_13 : Boolean;
      T_14 : Boolean;
      function Receive_Response_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Receive_Response_Invariant);
      -- specs/coap_client.rflx:71:10
      CoAP.CoAP_Message.Verify_Message (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:74:16
      T_0 := CoAP.CoAP_Message.Well_Formed_Message (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:74:35
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Receive_Response_Invariant);
         goto Finalize_Receive_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:74:35
      T_1 := CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:74:35
      T_2 := RFLX.RFLX_Types.Base_Integer (T_1) = RFLX.RFLX_Types.Base_Integer (Ctx.P.Messsage_ID);
      -- specs/coap_client.rflx:74:16
      T_3 := T_0
      and then T_2;
      -- specs/coap_client.rflx:74:73
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Receive_Response_Invariant);
         goto Finalize_Receive_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:74:73
      T_4 := CoAP.CoAP_Message.Get_Class (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:74:73
      T_5 := T_4 = CoAP.Success;
      -- specs/coap_client.rflx:76:16
      T_6 := CoAP.CoAP_Message.Well_Formed_Message (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:76:35
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Message_ID) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Receive_Response_Invariant);
         goto Finalize_Receive_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:76:35
      T_7 := CoAP.CoAP_Message.Get_Message_ID (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:76:35
      T_8 := RFLX.RFLX_Types.Base_Integer (T_7) = RFLX.RFLX_Types.Base_Integer (Ctx.P.Messsage_ID);
      -- specs/coap_client.rflx:76:16
      T_9 := T_6
      and then T_8;
      -- specs/coap_client.rflx:77:17
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Receive_Response_Invariant);
         goto Finalize_Receive_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:77:17
      T_10 := CoAP.CoAP_Message.Get_Class (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:77:17
      T_11 := T_10 = CoAP.Client_Error;
      -- specs/coap_client.rflx:77:56
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Receive_Response_Invariant);
         goto Finalize_Receive_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:77:56
      T_12 := CoAP.CoAP_Message.Get_Class (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:77:56
      T_13 := T_12 = CoAP.Server_Error;
      -- specs/coap_client.rflx:77:17
      T_14 := T_11
      or else T_13;
      if
         T_3
         and then T_5
      then
         Ctx.P.Next_State := S_Success;
      elsif
         T_9
         and then T_14
      then
         Ctx.P.Next_State := S_Treat_Error_Response;
      else
         Ctx.P.Next_State := S_Receive_Response;
      end if;
      pragma Assert (Receive_Response_Invariant);
      <<Finalize_Receive_Response>>
   end Receive_Response;

   procedure Treat_Error_Response (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      OK : Boolean;
      T_15 : CoAP.Code_Class;
      T_16 : Boolean;
      T_17 : CoAP.Code_Class;
      T_18 : Boolean;
      function Treat_Error_Response_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Treat_Error_Response_Invariant);
      -- specs/coap_client.rflx:87:41
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Well_Formed (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Error_Response_Invariant);
         goto Finalize_Treat_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:87:10
      declare
         RFLX_Put_Options_And_Payload_Arg_0_Response : RFLX_Types.Bytes (RFLX_Types.Index'First .. RFLX_Types.Index'First + RFLX_Types.Length'(4095)) := (others => 0);
         RFLX_Put_Options_And_Payload_Arg_0_Response_Length : constant RFLX_Types.Length := RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload));
      begin
         if not (RFLX_Put_Options_And_Payload_Arg_0_Response'Length >= RFLX_Put_Options_And_Payload_Arg_0_Response_Length) then
            Ctx.P.Next_State := S_Failure;
            pragma Assert (Treat_Error_Response_Invariant);
            goto Finalize_Treat_Error_Response;
         end if;
         CoAP.CoAP_Message.Get_Options_And_Payload (Ctx.P.Response_Ctx, RFLX_Put_Options_And_Payload_Arg_0_Response (RFLX_Types.Index'First .. (if
             RFLX_Put_Options_And_Payload_Arg_0_Response_Length > 0
          then
             RFLX_Types.Index'First + RFLX_Put_Options_And_Payload_Arg_0_Response_Length - RFLX_Types.Length'(1)
          else
             (-1))));
         Put_Options_And_Payload (Ctx.E, RFLX_Put_Options_And_Payload_Arg_0_Response (RFLX_Types.Index'First .. (if
             RFLX_Put_Options_And_Payload_Arg_0_Response_Length > 0
          then
             RFLX_Types.Index'First + RFLX_Put_Options_And_Payload_Arg_0_Response_Length - RFLX_Types.Length'(1)
          else
             (-1))), OK);
      end;
      -- specs/coap_client.rflx:90:23
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Error_Response_Invariant);
         goto Finalize_Treat_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:90:23
      T_15 := CoAP.CoAP_Message.Get_Class (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:90:23
      T_16 := T_15 = CoAP.Client_Error;
      -- specs/coap_client.rflx:92:23
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Class) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Error_Response_Invariant);
         goto Finalize_Treat_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:92:23
      T_17 := CoAP.CoAP_Message.Get_Class (Ctx.P.Response_Ctx);
      -- specs/coap_client.rflx:92:23
      T_18 := T_17 = CoAP.Server_Error;
      if
         OK
         and then T_16
      then
         Ctx.P.Next_State := S_Treat_Client_Error_Response;
      elsif
         OK
         and then T_18
      then
         Ctx.P.Next_State := S_Treat_Server_Error_Response;
      else
         Ctx.P.Next_State := S_Failure;
      end if;
      pragma Assert (Treat_Error_Response_Invariant);
      <<Finalize_Treat_Error_Response>>
   end Treat_Error_Response;

   procedure Treat_Client_Error_Response (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      OK : Boolean;
      function Treat_Client_Error_Response_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Treat_Client_Error_Response_Invariant);
      -- specs/coap_client.rflx:101:33
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Client_Error_Code) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Client_Error_Response_Invariant);
         goto Finalize_Treat_Client_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:101:10
      Put_Client_Error (Ctx.E, CoAP.CoAP_Message.Get_Client_Error_Code (Ctx.P.Response_Ctx), OK);
      if OK then
         Ctx.P.Next_State := S_Final;
      else
         Ctx.P.Next_State := S_Failure;
      end if;
      pragma Assert (Treat_Client_Error_Response_Invariant);
      <<Finalize_Treat_Client_Error_Response>>
   end Treat_Client_Error_Response;

   procedure Treat_Server_Error_Response (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      OK : Boolean;
      function Treat_Server_Error_Response_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Treat_Server_Error_Response_Invariant);
      -- specs/coap_client.rflx:113:33
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Valid (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Server_Error_Code) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Treat_Server_Error_Response_Invariant);
         goto Finalize_Treat_Server_Error_Response;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:113:10
      Put_Server_Error (Ctx.E, CoAP.CoAP_Message.Get_Server_Error_Code (Ctx.P.Response_Ctx), OK);
      if OK then
         Ctx.P.Next_State := S_Final;
      else
         Ctx.P.Next_State := S_Failure;
      end if;
      pragma Assert (Treat_Server_Error_Response_Invariant);
      <<Finalize_Treat_Server_Error_Response>>
   end Treat_Server_Error_Response;

   procedure Success (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      OK : Boolean;
      function Success_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Success_Invariant);
      -- specs/coap_client.rflx:125:41
      pragma Warnings (Off, "condition can only be False if invalid values present");
      pragma Warnings (Off, "condition is always False");
      pragma Warnings (Off, "this code can never be executed and has been deleted");
      pragma Warnings (Off, "statement has no effect");
      pragma Warnings (Off, "this statement is never reached");
      if not CoAP.CoAP_Message.Well_Formed (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload) then
         Ctx.P.Next_State := S_Failure;
         pragma Assert (Success_Invariant);
         goto Finalize_Success;
      end if;
      pragma Warnings (On, "this statement is never reached");
      pragma Warnings (On, "statement has no effect");
      pragma Warnings (On, "this code can never be executed and has been deleted");
      pragma Warnings (On, "condition is always False");
      pragma Warnings (On, "condition can only be False if invalid values present");
      -- specs/coap_client.rflx:125:10
      declare
         RFLX_Put_Options_And_Payload_Arg_0_Response : RFLX_Types.Bytes (RFLX_Types.Index'First .. RFLX_Types.Index'First + RFLX_Types.Length'(4095)) := (others => 0);
         RFLX_Put_Options_And_Payload_Arg_0_Response_Length : constant RFLX_Types.Length := RFLX_Types.To_Length (CoAP.CoAP_Message.Field_Size (Ctx.P.Response_Ctx, CoAP.CoAP_Message.F_Options_And_Payload));
      begin
         if not (RFLX_Put_Options_And_Payload_Arg_0_Response'Length >= RFLX_Put_Options_And_Payload_Arg_0_Response_Length) then
            Ctx.P.Next_State := S_Failure;
            pragma Assert (Success_Invariant);
            goto Finalize_Success;
         end if;
         CoAP.CoAP_Message.Get_Options_And_Payload (Ctx.P.Response_Ctx, RFLX_Put_Options_And_Payload_Arg_0_Response (RFLX_Types.Index'First .. (if
             RFLX_Put_Options_And_Payload_Arg_0_Response_Length > 0
          then
             RFLX_Types.Index'First + RFLX_Put_Options_And_Payload_Arg_0_Response_Length - RFLX_Types.Length'(1)
          else
             (-1))));
         Put_Options_And_Payload (Ctx.E, RFLX_Put_Options_And_Payload_Arg_0_Response (RFLX_Types.Index'First .. (if
             RFLX_Put_Options_And_Payload_Arg_0_Response_Length > 0
          then
             RFLX_Types.Index'First + RFLX_Put_Options_And_Payload_Arg_0_Response_Length - RFLX_Types.Length'(1)
          else
             (-1))), OK);
      end;
      if OK then
         Ctx.P.Next_State := S_Final;
      else
         Ctx.P.Next_State := S_Failure;
      end if;
      pragma Assert (Success_Invariant);
      <<Finalize_Success>>
   end Success;

   procedure Failure (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
      function Failure_Invariant return Boolean is
        (Ctx.P.Slots.Slot_Ptr_1 = null
         and Ctx.P.Slots.Slot_Ptr_2 = null)
       with
        Annotate =>
          (GNATprove, Inline_For_Proof),
        Ghost;
   begin
      pragma Assert (Failure_Invariant);
      Ctx.P.Next_State := S_Final;
      pragma Assert (Failure_Invariant);
   end Failure;

   procedure Initialize (Ctx : in out Context) is
      Request_Buffer : RFLX_Types.Bytes_Ptr;
      Response_Buffer : RFLX_Types.Bytes_Ptr;
   begin
      CoAP_Client.Session.FSM_Allocator.Initialize (Ctx.P.Slots, Ctx.P.Memory);
      Request_Buffer := Ctx.P.Slots.Slot_Ptr_1;
      pragma Warnings (Off, "unused assignment");
      Ctx.P.Slots.Slot_Ptr_1 := null;
      pragma Warnings (On, "unused assignment");
      CoAP.CoAP_Message.Initialize (Ctx.P.Request_Ctx, Request_Buffer);
      Response_Buffer := Ctx.P.Slots.Slot_Ptr_2;
      pragma Warnings (Off, "unused assignment");
      Ctx.P.Slots.Slot_Ptr_2 := null;
      pragma Warnings (On, "unused assignment");
      CoAP.CoAP_Message.Initialize (Ctx.P.Response_Ctx, Response_Buffer);
      Ctx.P.Next_State := S_Create_Request;
   end Initialize;

   procedure Finalize (Ctx : in out Context) is
      Request_Buffer : RFLX_Types.Bytes_Ptr;
      Response_Buffer : RFLX_Types.Bytes_Ptr;
   begin
      pragma Warnings (Off, """Ctx.P.Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      CoAP.CoAP_Message.Take_Buffer (Ctx.P.Request_Ctx, Request_Buffer);
      pragma Warnings (On, """Ctx.P.Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      pragma Assert (Ctx.P.Slots.Slot_Ptr_1 = null);
      pragma Assert (Request_Buffer /= null);
      Ctx.P.Slots.Slot_Ptr_1 := Request_Buffer;
      pragma Assert (Ctx.P.Slots.Slot_Ptr_1 /= null);
      pragma Warnings (Off, """Ctx.P.Response_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      CoAP.CoAP_Message.Take_Buffer (Ctx.P.Response_Ctx, Response_Buffer);
      pragma Warnings (On, """Ctx.P.Response_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      pragma Assert (Ctx.P.Slots.Slot_Ptr_2 = null);
      pragma Assert (Response_Buffer /= null);
      Ctx.P.Slots.Slot_Ptr_2 := Response_Buffer;
      pragma Assert (Ctx.P.Slots.Slot_Ptr_2 /= null);
      CoAP_Client.Session.FSM_Allocator.Finalize (Ctx.P.Slots);
      Ctx.P.Next_State := S_Final;
   end Finalize;

   procedure Reset_Messages_Before_Write (Ctx : in out Context) with
     Pre =>
       Initialized (Ctx),
     Post =>
       Initialized (Ctx)
   is
   begin
      case Ctx.P.Next_State is
         when S_Create_Request | S_Send_Request =>
            null;
         when S_Receive_Response =>
            CoAP.CoAP_Message.Reset (Ctx.P.Response_Ctx, Ctx.P.Response_Ctx.First, Ctx.P.Response_Ctx.First - 1);
         when S_Treat_Error_Response | S_Treat_Client_Error_Response | S_Treat_Server_Error_Response | S_Success | S_Failure | S_Final =>
            null;
      end case;
   end Reset_Messages_Before_Write;

   procedure Tick (Ctx : in out Context) is
   begin
      case Ctx.P.Next_State is
         when S_Create_Request =>
            Create_Request (Ctx);
         when S_Send_Request =>
            Send_Request (Ctx);
         when S_Receive_Response =>
            Receive_Response (Ctx);
         when S_Treat_Error_Response =>
            Treat_Error_Response (Ctx);
         when S_Treat_Client_Error_Response =>
            Treat_Client_Error_Response (Ctx);
         when S_Treat_Server_Error_Response =>
            Treat_Server_Error_Response (Ctx);
         when S_Success =>
            Success (Ctx);
         when S_Failure =>
            Failure (Ctx);
         when S_Final =>
            null;
      end case;
      Reset_Messages_Before_Write (Ctx);
   end Tick;

   function In_IO_State (Ctx : Context) return Boolean is
     (Ctx.P.Next_State in S_Send_Request | S_Receive_Response);

   procedure Run (Ctx : in out Context) is
   begin
      Tick (Ctx);
      while
         Active (Ctx)
         and not In_IO_State (Ctx)
      loop
         pragma Loop_Invariant (Initialized (Ctx));
         Tick (Ctx);
      end loop;
   end Run;

   procedure Read (Ctx : Context; Chan : Channel; Buffer : out RFLX_Types.Bytes; Offset : RFLX_Types.Length := 0) is
      function Read_Pre (Message_Buffer : RFLX_Types.Bytes) return Boolean is
        (Buffer'Length > 0
         and then Offset < Message_Buffer'Length);
      procedure Read (Message_Buffer : RFLX_Types.Bytes) with
        Pre =>
          Read_Pre (Message_Buffer)
      is
         Length : constant RFLX_Types.Length := RFLX_Types.Length'Min (Buffer'Length, Message_Buffer'Length - Offset);
         Buffer_Last : constant RFLX_Types.Index := Buffer'First + (Length - RFLX_Types.Length'(1));
      begin
         Buffer (Buffer'First .. RFLX_Types.Index (Buffer_Last)) := Message_Buffer (RFLX_Types.Index (RFLX_Types.Length (Message_Buffer'First) + Offset) .. Message_Buffer'First + Offset + (Length - RFLX_Types.Length'(1)));
      end Read;
      procedure CoAP_CoAP_Message_Read is new CoAP.CoAP_Message.Generic_Read (Read, Read_Pre);
   begin
      Buffer := (others => 0);
      case Chan is
         when C_Transport =>
            case Ctx.P.Next_State is
               when S_Send_Request =>
                  CoAP_CoAP_Message_Read (Ctx.P.Request_Ctx);
               when others =>
                  pragma Warnings (Off, "unreachable code");
                  null;
                  pragma Warnings (On, "unreachable code");
            end case;
      end case;
   end Read;

   procedure Write (Ctx : in out Context; Chan : Channel; Buffer : RFLX_Types.Bytes; Offset : RFLX_Types.Length := 0) is
      Write_Buffer_Length : constant RFLX_Types.Length := Write_Buffer_Size (Ctx, Chan);
      function Write_Pre (Context_Buffer_Length : RFLX_Types.Length; Offset : RFLX_Types.Length) return Boolean is
        (Buffer'Length > 0
         and then Context_Buffer_Length = Write_Buffer_Length
         and then Offset <= RFLX_Types.Length'Last - Buffer'Length
         and then Buffer'Length + Offset <= Write_Buffer_Length);
      procedure Write (Message_Buffer : out RFLX_Types.Bytes; Length : out RFLX_Types.Length; Context_Buffer_Length : RFLX_Types.Length; Offset : RFLX_Types.Length) with
        Pre =>
          Write_Pre (Context_Buffer_Length, Offset)
          and then Offset <= RFLX_Types.Length'Last - Message_Buffer'Length
          and then Message_Buffer'Length + Offset = Write_Buffer_Length,
        Post =>
          Length <= Message_Buffer'Length
      is
      begin
         Length := Buffer'Length;
         Message_Buffer := (others => 0);
         Message_Buffer (Message_Buffer'First .. RFLX_Types.Index (RFLX_Types.Length (Message_Buffer'First) - 1 + Length)) := Buffer;
      end Write;
      procedure CoAP_CoAP_Message_Write is new CoAP.CoAP_Message.Generic_Write (Write, Write_Pre);
   begin
      case Chan is
         when C_Transport =>
            case Ctx.P.Next_State is
               when S_Receive_Response =>
                  CoAP_CoAP_Message_Write (Ctx.P.Response_Ctx, Offset);
               when others =>
                  pragma Warnings (Off, "unreachable code");
                  null;
                  pragma Warnings (On, "unreachable code");
            end case;
      end case;
   end Write;

end RFLX.CoAP_Client.Session.FSM;
